# 串口-中断模式
***
**使用中断的原因：**

轮询模式会导致CPU资源的浪费，中断模式可以解决这个问题。

中断模式下，串口接收到数据后会产生一个中断请求，CPU会在中断服务函数中处理接收到的数据。
***
## 轮询模式的底层机制：
在STM32中，每个发送串口内部有这样两个寄存器：
1. **发送数据**寄存器（TDR）
2. **发送移位**寄存器
### 轮询模式下的串口发送:
当我们调用函数
~~~C
HAL_UART_Transmit(&huart2,message,strlen(message),HAL_MAX_DELAY);
~~~
STM32的CPU会将message中的数据一个一个的写入TDR寄存器，然后发送数据寄存器TDR寄存器会按照我们设定的比特率将数据传输到发送移位寄存器，发送移位寄存器会将数据转换成高低电平发送到串口TX引脚。

发送数据寄存器中的数据会在发送移位寄存器发送完成后，被移动到发送移位寄存器中，这样就可以继续发送下一个数据。

在此过程中，CPU会不断地查询发送移位寄存器的状态，当发送移位寄存器的状态为空时，CPU会将下一个数据写入发送数据寄存器，直到所有数据发送完成或是超时。

### 轮询模式下的串口接收:
每个接收串口内部有这样两个寄存器：
1. **接收数据**寄存器（RDR）
2. **接收移位**寄存器
当我们调用函数
~~~C
HAL_UART_Receive(&huart2,message,srtlen(message),HAL_MAX_DELAY);
~~~
RX接收的高低电平信号，依次**转换后存入接收移位寄存器**，接收移位寄存器**接受完一帧的数据后**，会将数据**存入接收数据寄存器**。

CPU会一直查询**接收数据寄存器**中是否有新数据可以读取，当接收数据寄存器中有数据时，CPU会将数据读取到message中，直到读取完我们期望的字节数或是超时。

**所以在轮询模式下，无论是发送还是接收，CPU都需要一轮一轮的查询寄存器是否可用**

**我们称这种一直等待使程序暂时无法向下执行的状态为堵塞**
***
为了解决这个问题，我们可以使用中断模式

**在中断模式中，讲数据塞进寄存器后就可以继续执行其他的任务了**

当**发送移位寄存器**中的数据被发送出去以后，会产生一个**发送数据寄存器空中断**

这个**中断会通知CPU**，发送数据寄存器已经空了，可以继续发送下一个数据。然后**CPU会调用中断服务函数**，**将下一个数据写入发送数据寄存器**

#### 实现中断模式的步骤：
1. 在`CubeMX/NVIC`**开启USART串口中断**

使用中断发送的函数和轮询发送的函数很相似：
~~~C
//轮询发送的函数：
HAL_UART_Transmit(&huart2, com, 2, HAL_MAX_DELAY);
//中断发送的函数：
HAL_UART_Transmit_IT(&huart2, com, 2);
//中断发送不需要长时间占用CPU，所以不需要HAL_MAX_DELAY
~~~
开启中断接收的函数和轮询接收的函数也很相似：
~~~C
//轮询接收的函数：
HAL_UART_Receive(&huart2, com, 2, HAL_MAX_DELAY);
//中断接收的函数：
HAL_UART_Receive_IT(&huart2, com, 2);
//中断接收不需要长时间占用CPU，所以不需要HAL_MAX_DELAY
~~~
如果只是简单的替换掉函数：
~~~C
 while (1)
  {
        HAL_UART_Receive_IT(&huart2, com, 2);
        HAL_UART_Transmit_IT(&huart2, com, 2);
        GPIO_PinState state = GPIO_PIN_RESET;
      if (com[1] == '1')
      {
          state = GPIO_PIN_SET;
      }
      if (com[0]=='R')
      {
          HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, state);
      } else if (com[0]=='G')
      {
          HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, state);
      } else if (com[0]=='B')
      {
          HAL_GPIO_WritePin(LED_BULE_GPIO_Port, LED_BULE_Pin, state);
      }
  }
~~~
因为**中断函数不会阻塞程序的执行**，所以还没等到接收到数据时，就会接着向下执行下去

这就导致了：可能上次的数据还没有接收完，就又会开启串口中断接收









