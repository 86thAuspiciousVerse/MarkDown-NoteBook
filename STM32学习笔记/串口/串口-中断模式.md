# 串口-中断模式
***
**使用中断的原因：**

轮询模式会导致CPU资源的浪费，中断模式可以解决这个问题。

中断模式下，串口接收到数据后会产生一个中断请求，CPU会在中断服务函数中处理接收到的数据。
***
## 轮询模式的底层机制：
在STM32中，每个发送串口内部有这样两个寄存器：
1. **发送数据**寄存器（TDR）
2. **发送移位**寄存器
### 轮询模式下的串口发送:
当我们调用函数
~~~C
HAL_UART_Transmit(&huart2,message,strlen(message),HAL_MAX_DELAY);
~~~
STM32的CPU会将message中的数据一个一个的写入TDR寄存器，然后发送数据寄存器TDR寄存器会按照我们设定的比特率将数据传输到发送移位寄存器，发送移位寄存器会将数据转换成高低电平发送到串口TX引脚。

发送数据寄存器中的数据会在发送移位寄存器发送完成后，被移动到发送移位寄存器中，这样就可以继续发送下一个数据。

在此过程中，CPU会不断地查询发送移位寄存器的状态，当发送移位寄存器的状态为空时，CPU会将下一个数据写入发送数据寄存器，直到所有数据发送完成或是超时。

### 轮询模式下的串口接收:
每个接收串口内部有这样两个寄存器：
1. **接收数据**寄存器（RDR）
2. **接收移位**寄存器
当我们调用函数
~~~C
HAL_UART_Receive(&huart2,message,srtlen(message),HAL_MAX_DELAY);
~~~
RX接收的高低电平信号，依次**转换后存入接收移位寄存器**，接收移位寄存器**接受完一帧的数据后**，会将数据**存入接收数据寄存器**。

CPU会一直查询**接收数据寄存器**中是否有新数据可以读取，当接收数据寄存器中有数据时，CPU会将数据读取到message中，直到读取完我们期望的字节数或是超时。

**所以在轮询模式下，无论是发送还是接收，CPU都需要一轮一轮的查询寄存器是否可用**

**我们称这种一直等待使程序暂时无法向下执行的状态为堵塞**
***
为了解决这个问题，我们可以使用中断模式

**在中断模式中，讲数据塞进寄存器后就可以继续执行其他的任务了**















